#!/usr/bin/env bash
################################################################################
#: Title       : Custom_backup
#: Date        : 2017-Nov-30
#: Author      : Anthony Tilelli
#: Version     : .01
#: Description : Runs backups defined in configuration file
#: Options     : PENDING
################################################################################

# strict mode (http://redsymbol.net/articles/unofficial-bash-strict-mode/)
set -euo pipefail
#readonly ORIGINAL_IFS="$IFS"
#IFS=$'\n\t'

# CONSTANTS
readonly GL_BACKUP_CONFIG="backup.config"
readonly GL_PRMG_CONFIG="prgm.config"

# FUNCTIONS
function fail() {
  # Outputs error-message and force-quits script

  local -r ERRORCODE="$1"
  local -r ERROR_MESSAGE="$2"
  printf "ERROR %d: %s\\n" "$ERRORCODE" "$ERROR_MESSAGE" >&2
  exit "$ERRORCODE"
}

function validate_config_file() {
  # Evaluates config files:
  # - Readable/exist
  # - ASCII text
  # - Owned by script user or root
  # - Writable by owner only.

  # Return:
  # Ouputs file and path if validated
  # Returns 0 or exits with failure

  local -r USERID="$1" #UID of the user calling script
  local -r CONFIG="$2" #File to evaluate
  local config_user="" #config user owner

  #Validates config files is readable by script user
  if [[ -r "$CONFIG" ]]; then
    #Is file ASCII text?
    if [[ "$(file "$CONFIG")" =~ ": ASCII text" ]] ; then
      config_user=$(stat -c %u "$CONFIG")
      #If file owned by root or USERID
      if (( config_user == 0 )) || (( config_user == "$USERID" )) ; then
        #writable by owner only??
        if [[ "$(stat -c %A "$CONFIG")" != -r???--?-- ]]; then
          fail 10 "Wrong permissions on file: $CONFIG.(Is file write/executable by group/other?)"
        fi
      else
        fail 9 "\"$CONFIG\" is not owned by root or $USERID (File owner: $config_user)"
      fi
    else
      fail 8 "File \"$CONFIG\" is not ASCII text type"
    fi
  else
    fail 7 "Unable to use file: \"$CONFIG\". (Does files exist and is it readable?)"
  fi
  printf "%s\\n" "$CONFIG"
  return 0
}

function load_config() {
  # Reads in backup config entry and convets to global variables

  # Modifies Global variables:
  # - Gl_cfg_Program
  # - Gl_cfg_Arguments
  # - Gl_cfg_Source
  # - Gl_cfg_Backup
  # - Gl_cfg_cd
  # - Gl_cfg_UMASK

  local -r CFG_BID="$1" #assumes there are no #
  local -r CFG_ACTION="$2"
  local -r BACKUP_CONFIG="$3" #assumed validated

  local -r CONFIG_LINE=$(grep "^$CFG_BID:.*$CFG_ACTION" "$BACKUP_CONFIG" | sed 's/\s*#.*//g')
  #sed - removes comments from end of lines
  local -r NUM_OF_ENTRIES=$(grep -c "^$CFG_BID:.*$CFG_ACTION" "$BACKUP_CONFIG")
  local -r NUM_OF_COLUMNS=$(printf "%s\\n" "$CONFIG_LINE" | sed 's/[^:]//g' | wc -c)

  if (( NUM_OF_ENTRIES == 1 )); then
    if (( NUM_OF_COLUMNS == 8 )); then
      Gl_cfg_Program=$(printf "%s\\n"   "$CONFIG_LINE" | cut -f 3 -d ':')
      Gl_cfg_Arguments=$(printf "%s\\n" "$CONFIG_LINE" | cut -f 4 -d ':')
      Gl_cfg_Source=$(printf "%s\\n"    "$CONFIG_LINE" | cut -f 5 -d ':')
      Gl_cfg_Backup=$(printf "%s\\n"    "$CONFIG_LINE" | cut -f 6 -d ':')
      Gl_cfg_cd=$(printf "%s\\n"        "$CONFIG_LINE" | cut -f 7 -d ':')
      Gl_cfg_UMASK=$(printf "%s\\n"     "$CONFIG_LINE" | cut -f 8 -d ':')
    else
      fail 4 "Entry \"$CONFIG_LINE\" is incorrect"
    fi
  else
    fail 3 "$NUM_OF_ENTRIES entries found in $GL_BACKUP_CONFIG for \"$Gl_cfg_BID:$Gl_cfg_Action\""
  fi
  #local IFS=:
  #set -- $CONFIG_LINE
  #echo "$@# $#"
  return 0
}

function find_config() {
  #Finds and processes config from given backup config file

  local -r CFG_BID="$1" #assumes there are no #
  local -r CFG_ACTION="$2"
  local -r BACKUP_CONFIG="$3" #assumed validated

  #Return Variables (expected set)
  # - cfg_Program
  # - cfg_Arguments
  # - cfg_Source
  # - cfg_Backup
  # - cfg_cd
  # - cfg_UMASK

  #checking if variable exists (prevent non-variable creation in function)
  local nothing
  nothing=${cfg_Program?"cfg_Program is not set"}
  nothing=${cfg_Arguments?"cfg_Arguments is not set"}
  nothing=${cfg_Source?"cfg_Source is not set"}
  nothing=${cfg_Backup?"cfg_Backup is not set"}
  nothing=${cfg_cd? "cfg_cd is not set"}
  nothing=${cfg_UMASK? "cfg_UMASK is not set"}

  local -r CONFIG_LINE=$(grep "^$CFG_BID:.*$CFG_ACTION" "$BACKUP_CONFIG" | sed 's/\s*#.*//g')
  #sed - removes comments from end of lines
  local IFS=:
  set -- $CONFIG_LINE
  if (( ${#} == 7 )) || (( ${#} == 8 )) ; then
    cfg_Program=$3
    cfg_Arguments=$4
    cfg_Source=$5
    cfg_Backup=$6
    cfg_cd=$7
    cfg_UMASK=${8-""} #$8 may be unset, defaults to empty
  elif ((${#} == 0)) ; then
    fail 3 "No entries found for \"${CFG_BID}:${CFG_ACTION}\""
  else
    fail 4 "Entry \"${CONFIG_LINE}\" is incorrect or more then one line was found"
  fi
}

function load_prgm() {
  # Reads in program prmg entry and convets to backup command

  # Reads Global variables
  # - Gl_cfg_Program
  # - Gl_cfg_Action
  # - GL_PRMG_CONFIG
  # - Gl_cfg_Program
  # - Gl_cfg_Arguments
  # - Gl_cfg_Sourc
  # - Gl_cfg_Backup

  # Modifies Global variables:
  # - Gl_backup_command

  local -r CONFIG_LINE=$(grep "$Gl_cfg_Program:.*$Gl_cfg_Action" "$GL_PRMG_CONFIG" | sed 's/\s*#.*//g')
  #sed - removes comments from end of lines
  local -r NUM_OF_ENTRIES=$(grep -c "$Gl_cfg_Program:.*$Gl_cfg_Action" "$GL_PRMG_CONFIG")
  local -r NUM_OF_COLUMNS=$(printf "%s\\n" "$CONFIG_LINE" | sed 's/[^:]//g' | wc -c)
  local entry=""

  if (( NUM_OF_ENTRIES == 1 )); then
    Gl_backup_command="$Gl_cfg_Program "
    for (( col=3; col<=NUM_OF_COLUMNS; col++ )) ; do
      entry=$(printf "%s\\n" "$CONFIG_LINE" | cut -f "$col" -d ':')
      case "$entry" in
        "arguments")  Gl_backup_command+="${Gl_cfg_Arguments} "   ;;
        "source")     Gl_backup_command+="\"${Gl_cfg_Source}\" "  ;;
        "backup")     Gl_backup_command+="\"${Gl_cfg_Backup}\" "  ;;
        *)
          Gl_backup_command="false"
          fail 6 "$entry is unknown (col: $col)"
          ;;
      esac
    done
  else
    fail 5 "$NUM_OF_ENTRIES entries found in $GL_PRMG_CONFIG for \"$Gl_cfg_Program:$Gl_cfg_Action\""
  fi
}

function run_backup () { #TODO: not fully working as intented
  # Change directory and umask, if needed,  and runs backup

  local -r BACKUP_COMMAND="${1}" #Command to run backup (required)
  local -r WORKING_DIR="${2:-/}"
  #Directory to change to before running backup (default /)
  local -r SET_UMASK="${3:-SKIP}"
  #umask to set before running backup (default SKIP)

  cd "${WORKING_DIR}"
  case $SET_UMASK in #ensuring is a valid umask
    SKIP) ;; #DO-NOTHING
    [0-7] | [0-7][0-7] | [0-7][0-7][0-7] | [0-7][0-7][0-7][0-7] )
      umask "${SET_UMASK}"
      ;;
    *) fail 11  "umask is invalid (${SET_UMASK})" ;;
  esac
  echo "$BACKUP_COMMAND" #PLACEHOLDER
  #$BACKUP_COMMAND # ERROR:not expanding $HOME
  #TODO HANDLE IF BACKUP COMMAND FAILES
}

function usage_short() {
  #outputs usage
  printf "%s -[ioRs]-[B=<BID>] [-D]\\n" "${0##*/}"
}

usage() {
  #OUTPUT
  #help information

  usage_short
  printf "\\nAction Parameters (choose one)\\n"
  printf "  -i  Run INITIAL Action\\n"
  printf "  -o  Run ONGOING Action\\n"
  printf "  -R  Run RESTORE Action\\n"
  printf "  -s  Run SHOW    Action\\n"
  printf "  -h  Prints help message and exits\\n"
  printf "Backup ID\\n"
  printf "  -B=  sets backup ID (must start with \`=\`)\\n"
}

function main() {
  # Reads Global variables
  # - GL_BACKUP_CONFIG
  # - GL_PRMG_CONFIG

  local cfg_BID=""
  local -u cfg_action=""
  local cfg_Program=""
  local cfg_BID=""
  local cfg_Action=""
  local cfg_Program=""
  local cfg_Arguments=""
  local cfg_Source=""
  local cfg_Backup=""
  local cfg_cd=""
  local cfg_UMASK=""
  local backup_command=""

  local -i action_count=0
  local -r VALID_BACKUP_CONFIG=$(validate_config_file "$UID" "$GL_BACKUP_CONFIG")
  local -r VALID_PRMG_CONFIG=$(validate_config_file "$UID" "$GL_PRMG_CONFIG")

  if (( $# == 0 )) ; then
    usage_short
    fail 15 "missing parameters"
  fi

  while getopts ":ioRshB:" opt; do
    case $opt in
      "i")  cfg_action="INITIAL" && action_count+=1 ;;
      "o")  cfg_action="ONGOING" && action_count+=1 ;;
      "R")  cfg_action="RESTORE" && action_count+=1 ;;
      "s")  cfg_action="SHOW"    && action_count+=1 ;;
      "h")  usage ; exit 0 ;;
      "B")
        if [[ -z "$cfg_BID" ]]; then
          if [[ $OPTARG =~ ^= ]]; then #$OPTARG must start with =
            cfg_BID="${OPTARG#=}" #removing starting "="
          else
           fail 17  "-B argument must start with \`=\` (OPTARG: ${OPTARG} is invalid)"
          fi
        else
          fail 16  "-B already set"
        fi
        ;;
      \?)  fail 13 "Invalid argument entered -${OPTARG}" ;;
      ":") fail 14 "-${OPTARG} requires an argument"     ;;
    esac
  done
  shift $((OPTIND-1))
  if (( action_count == 1 )) ; then
    if [[ $cfg_BID =~ ^# ]] ; then
      fail 18 "BID has # in it (${cfg_BID})"
    fi

    Gl_cfg_BID="$cfg_BID" # tmp
    Gl_cfg_Action="$cfg_action" #tmp
    echo "$cfg_BID $cfg_action"
    find_config "$cfg_BID" "$cfg_action" "$VALID_BACKUP_CONFIG"
    #load_config "$cfg_BID" "$cfg_action" "$VALID_BACKUP_CONFIG"
    #load_prgm

  echo $cfg_BID
  echo $cfg_action
  echo $cfg_Program
  echo $cfg_Arguments
  echo $cfg_Source
  echo $cfg_Backup
  echo $cfg_cd
  echo $cfg_UMASK
  echo "backup_command: $backup_command"

  #run_backup "$Gl_backup_command" "$Gl_cfg_cd" "$Gl_cfg_UMASK"

  else
    fail 12 "More or less then one action set (count: ${action_count})"
  fi
  return 0
}

main "$@"
exit 99
